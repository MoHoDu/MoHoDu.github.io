---
layout: post
title: "Computaional Thinking - logic 01"
excerpt: "SW Expert Academy - Computational Thinking - logic 1"

categories:
  - CT

tags:
  - [CT, SSAFY, Study]

toc: true
toc_sticky: true

date: 2022-04-29
last_modified_at: 2022-04-29
---

## Computational Thinking을 채워보자!

비전공자로 컴퓨팅 사고 기르기 1일차  
→ SW Expert Academy CT수업을 통해 먼저 개념을 잡자!

비전공자로 SSAFY 8기를 준비하게 되었고, SSAFY의 지원 절차에 대해 알아보니, 온라인 CBT 시험으로 Computational Thinking이라는 시험 과목이 있다는 것을 알았다.  
"비" 전공자로 혼자 독학해오다보니 그동안 놓친 부분이 있으리라고는 생각했지만.. 도저히 딱 보는 순간 무엇일까 감이 잡히지는 않았다.  
그래서 여러가지로 싸피 후기 등등.. 정보를 찾아보다보니 좋은 사이트로 SW Expert Academy라는 사이트를 알게 되었고, 그 곳에서 Computational Thinking 수업과정을 찾아 수강하게 되었다.

그런고로... 이 포스트부터 앞으로 몇 개의 포스트를 통해서 간단하게 수업 중에서 내가 몰랐던 중요 요점들만 추려서 정리해보고, 기록해보는 시간을 가져보기로 했다!!  
&nbsp;

### **↘︎ 나는 왜 프로그래밍이 어려울까?**

---

프로그래밍이 어려운 이유는 두 가지가 있다고 하셨다.

1. 프로그래밍 언어와 라이브러리
2. 논리(logic) : Soft Logic말고 Hard Logic

1번은 당연하게 우리는 어려울 것이라고 생각하면서 코딩을 시작한다. 나도 그랬다. 파이썬이 비교적 다른 언어에 비해서 입문이 쉽다고 했을 뿐이지.. 어렵지 않다라고는 과거에도 지금도 동의할 수 없다. ㅎㅎ

2번은 "어! 맞네." 하는 느낌이 들었다. 아무리 언어를 배우고 관련된 라이브러리를 익혀도 새로운 프로젝트를 만들어서 코딩을 하는데에 훅훅 해나가지 못했던 이유가 바로 이거 아니었을까 하는 생각이 확 들었다. 분명 처음부터 논리가 어려울거야라고 생각하지는 못했지만, 지금 와서는 정말로 동의하는 부분이 아닐 수 없었다.

논리라는 것은 또 두 가지로 나뉜다고 하셨다.

1. Soft Logic : 흔히들 직관이라는 것을 통해 푸는 것
2. Hard Logic : 프로그래밍에서 해야 하는 논리. 증명을 해야하고, 직관으로 접근하면 안 되는 것

이렇게만 말하셨다면 이해가 안 되었겠지만, 다행히 아주 간단한 예시를 몇 개 들어주셨다.

```
각 카드의 한 면에는 알파벳이, 뒷 면에는 숫자가 하나씩 써있다. 다음의 명체가 주어졌을 때에 이 명제가 참인지 확인하기 위해 반드시 뒤집어서 확인해야 하는 카드는 몇 개인가?

명제 : 한 면에 D라고 쓰여 있다면, 반드시 그 뒷 면에는 3이 쓰여있다.

카드 : D F 3 7
```

답은 무엇일까? 처음에는 D 하나만 골랐다. 당연히 D 뒤에 3이 있을 것이라고만 했으니까 F는 아니고, 숫자는 상관없지 않을까? 했다. 하지만 정답은...

```
정답 : 2개 (D와 7)
```

어째서 이런 답이 나온걸까?

사실 아주 간단한 논리 문제였다. D는 뒤에 무조건 3이 있는지 확인해야 하므로 보는 것이 맞고, 7은 그 뒷 면에 D가 아니라는 것을 확인해야 하므로 보아야 하는 것이다.  
만약에 그 뒷면에 D가 있다면.. 한 면이 D인 카드의 뒷 면이 3이 아니므로 명제가 틀려버리기 때문이다.

이를 다른 문제로 바꾸면 엄청 쉬워진다.

```
명제 : 만 20세 이상의 나이를 가진 사람만 맥주를 마실 수 있다.

이 명제가 참인지 확인하기 위해서 검사해야 할 사람은 총 몇명인가?
(사람의 나이 혹은 시킨 음료의 종류가 나열된다.)

사람 : 17세, 31세, 콜라, 맥주
```

답은 당연히 17세와 맥주를 시킨 사람이 될 것이다. 이는 딱히 설명이 없어도 다들 금방 이해가 되는 문제라고 생각된다. 나 역시 편의점 알바를 하고 있는 입장에서 직관적으로 교복을 입은 학생이 술을 사면 안되는 것을 당연히 알고, 맥주를 가져온 사람이 만 20세 이상인지 확인해야 되는 것 역시 당연하다는 것을 잘 알고 있기에 이 문제는 쉽게 풀렸다.

```
답 : 2명 (17세, 맥주를 시킨 사람)
```

그런데, 사실 위 두 문제는 사례만 다르고 논리적으로는 완전히 같은 문제였다. 그런데도 나를 포함한 많은 사람들은 앞의 문제는 어렵다고 느끼고, 뒤의 문제는 상당히 쉽다고 느끼기 일쑤였다. 그렇다면 왜 그렇게 느끼게 된 것일까?

우리는 두 번째 문제를 풀면서 로직을 썼다고 표현할 수 없다고 한다. 왜냐면 증명을 통해서 결정한 것이 아닌, 경험으로 쌓인 직관을 통해서 풀었기 때문이다. 바로 이런 식의 논리를 'Soft Logic'이라고 한다.  
반대로 앞의 문제는 그럴만한 경험이 부족하고, 직관으로 풀 수 없기 때문에 답을 본 뒤에 왜 그런 답이 나왔는지 다시 증명하는 과정을 거쳤다. 이렇게 증명을 통해 답을 도출해내는 과정을 'Hard Logic'이라고 부르며,프로그래밍에서 문제를 풀기 위한 알고리즘들은 모두 이 'Hard Logic'을 통해 보아야 이해가 된다.

즉, 우리가 알고리즘을 배울 때에 이해가 안 되었던 것은 보통

1. 직관으로 이해하려고 해서
2. 증명을 안 했거나, 안 보아서
3. 가끔 직관으로 이해가 되는 알고리즘을 보고 모든 알고리즘이 직관으로 이해된다고 착각해서

라는 총 세 가지의 이유일 가능성이 농후했을 것이다.

### **↘︎ 논리와 증명**

즉, 논리를 통해 문제를 풀기 위해서는 그 문제를 증명하는 능력이 필요하다.  
그러면서 교수님은 간단한 예를 들어주셨는데 그 명제를 증명하는 데에서 또 간단한 논리들을 알 수 있었다.

```
각 명제들을 명제식 형태로 작성하고, 참인지 거짓인지를 판단하시오.

1. 만약 0이 홀수라면, 미국에서 2080년 월드컵이 열린다.
2. 만약 19893827938274839이 Prime Number라면, 2는 짝수이다.
```

여기서 우리는 2080년에 미국에서 월드컵이 열리는지, 2번째의 어마어마한 수가 소수인지 알 방도가 없다.  
하지만, 그럼에도 이 전체 명제가 옳은지는 판단할 수 있는 로직이 있다.

```
1. 0이 홀수가 아니기 때문에, 뒤에 결과로 도출되는 명제가 참이든 거짓이든 전체 명제는 참이다.

2. 결과적으로 2가 짝수가 맞다는 것을 알기 때문에 앞에 조건의 명제가 참이든 거짓이든 전체 명제는 참이다.
```

즉, 우리는 조건 명제가 **거짓**이라면 무조건 전체 명제가 참이라는 것과  
결과 명제가 **참**이라면 무조건 전체 명제가 참이 된다는 간단하고도 중요한 규칙을 알게 되었다.
