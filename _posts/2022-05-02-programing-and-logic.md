---
layout: post
title: "Computaional Thinking - logic 01"
excerpt: "SW Expert Academy - Computational Thinking - logic 1"

categories:
  - CT

tags:
  - [CT, SSAFY, Study]

toc: true
toc_sticky: true

date: 2022-05-02
last_modified_at: 2022-05-03
---

## Computational Thinking을 채워보자!

비전공자로 컴퓨팅 사고 기르기 1일차  
→ SW Expert Academy CT수업을 통해 먼저 개념을 잡자!

비전공자로 SSAFY 8기를 준비하게 되었고, SSAFY의 지원 절차에 대해 알아보니, 온라인 CBT 시험으로 Computational Thinking이라는 시험 과목이 있다는 것을 알았다.  
"비" 전공자로 혼자 독학해오다보니 그동안 놓친 부분이 있으리라고는 생각했지만.. 도저히 딱 보는 순간 무엇일까 감이 잡히지는 않았다.  
그래서 여러가지로 싸피 후기 등등.. 정보를 찾아보다보니 좋은 사이트로 SW Expert Academy라는 사이트를 알게 되었고, 그 곳에서 Computational Thinking 수업과정을 찾아 수강하게 되었다.

그런고로... 이 포스트부터 앞으로 몇 개의 포스트를 통해서 간단하게 수업 중에서 내가 몰랐던 중요 요점들만 추려서 정리해보고, 기록해보는 시간을 가져보기로 했다!!  
&nbsp;

### **↘︎ 나는 왜 프로그래밍이 어려울까?**

---

프로그래밍이 어려운 이유는 두 가지가 있다고 하셨다.

1. 프로그래밍 언어와 라이브러리
2. 논리(logic) : Soft Logic말고 Hard Logic

1번은 당연하게 우리는 어려울 것이라고 생각하면서 코딩을 시작한다. 나도 그랬다. 파이썬이 비교적 다른 언어에 비해서 입문이 쉽다고 했을 뿐이지.. 어렵지 않다라고는 과거에도 지금도 동의할 수 없다. ㅎㅎ

2번은 "어! 맞네." 하는 느낌이 들었다. 아무리 언어를 배우고 관련된 라이브러리를 익혀도 새로운 프로젝트를 만들어서 코딩을 하는데에 훅훅 해나가지 못했던 이유가 바로 이거 아니었을까 하는 생각이 확 들었다. 분명 처음부터 논리가 어려울거야라고 생각하지는 못했지만, 지금 와서는 정말로 동의하는 부분이 아닐 수 없었다.

논리라는 것은 또 두 가지로 나뉜다고 하셨다.

1. Soft Logic : 흔히들 직관이라는 것을 통해 푸는 것
2. Hard Logic : 프로그래밍에서 해야 하는 논리. 증명을 해야하고, 직관으로 접근하면 안 되는 것

이렇게만 말하셨다면 이해가 안 되었겠지만, 다행히 아주 간단한 예시를 몇 개 들어주셨다.

```
각 카드의 한 면에는 알파벳이, 뒷 면에는 숫자가 하나씩 써있다. 다음의 명체가 주어졌을 때에 이 명제가 참인지 확인하기 위해 반드시 뒤집어서 확인해야 하는 카드는 몇 개인가?

명제 : 한 면에 D라고 쓰여 있다면, 반드시 그 뒷 면에는 3이 쓰여있다.

카드 : D F 3 7
```

답은 무엇일까? 처음에는 D 하나만 골랐다. 당연히 D 뒤에 3이 있을 것이라고만 했으니까 F는 아니고, 숫자는 상관없지 않을까? 했다. 하지만 정답은...

```
정답 : 2개 (D와 7)
```

어째서 이런 답이 나온걸까?

사실 아주 간단한 논리 문제였다. D는 뒤에 무조건 3이 있는지 확인해야 하므로 보는 것이 맞고, 7은 그 뒷 면에 D가 아니라는 것을 확인해야 하므로 보아야 하는 것이다.  
만약에 그 뒷면에 D가 있다면.. 한 면이 D인 카드의 뒷 면이 3이 아니므로 명제가 틀려버리기 때문이다.

이를 다른 문제로 바꾸면 엄청 쉬워진다.

```
명제 : 만 20세 이상의 나이를 가진 사람만 맥주를 마실 수 있다.

이 명제가 참인지 확인하기 위해서 검사해야 할 사람은 총 몇명인가?
(사람의 나이 혹은 시킨 음료의 종류가 나열된다.)

사람 : 17세, 31세, 콜라, 맥주
```

답은 당연히 17세와 맥주를 시킨 사람이 될 것이다. 이는 딱히 설명이 없어도 다들 금방 이해가 되는 문제라고 생각된다. 나 역시 편의점 알바를 하고 있는 입장에서 직관적으로 교복을 입은 학생이 술을 사면 안되는 것을 당연히 알고, 맥주를 가져온 사람이 만 20세 이상인지 확인해야 되는 것 역시 당연하다는 것을 잘 알고 있기에 이 문제는 쉽게 풀렸다.

```
답 : 2명 (17세, 맥주를 시킨 사람)
```

그런데, 사실 위 두 문제는 사례만 다르고 논리적으로는 완전히 같은 문제였다. 그런데도 나를 포함한 많은 사람들은 앞의 문제는 어렵다고 느끼고, 뒤의 문제는 상당히 쉽다고 느끼기 일쑤였다. 그렇다면 왜 그렇게 느끼게 된 것일까?

우리는 두 번째 문제를 풀면서 로직을 썼다고 표현할 수 없다고 한다. 왜냐면 증명을 통해서 결정한 것이 아닌, 경험으로 쌓인 직관을 통해서 풀었기 때문이다. 바로 이런 식의 논리를 'Soft Logic'이라고 한다.  
반대로 앞의 문제는 그럴만한 경험이 부족하고, 직관으로 풀 수 없기 때문에 답을 본 뒤에 왜 그런 답이 나왔는지 다시 증명하는 과정을 거쳤다. 이렇게 증명을 통해 답을 도출해내는 과정을 'Hard Logic'이라고 부르며,프로그래밍에서 문제를 풀기 위한 알고리즘들은 모두 이 'Hard Logic'을 통해 보아야 이해가 된다.

즉, 우리가 알고리즘을 배울 때에 이해가 안 되었던 것은 보통

1. 직관으로 이해하려고 해서
2. 증명을 안 했거나, 안 보아서
3. 가끔 직관으로 이해가 되는 알고리즘을 보고 모든 알고리즘이 직관으로 이해된다고 착각해서

라는 총 세 가지의 이유일 가능성이 농후했을 것이다.

### **↘︎ 논리와 증명**

즉, 논리를 통해 문제를 풀기 위해서는 그 문제를 증명하는 능력이 필요하다.  
그러면서 교수님은 간단한 예를 들어주셨는데 그 명제를 증명하는 데에서 또 간단한 논리들을 알 수 있었다.

```
각 명제들을 명제식 형태로 작성하고, 참인지 거짓인지를 판단하시오.

1. 만약 0이 홀수라면, 미국에서 2080년 월드컵이 열린다.
2. 만약 19893827938274839이 Prime Number라면, 2는 짝수이다.
```

여기서 우리는 2080년에 미국에서 월드컵이 열리는지, 2번째의 어마어마한 수가 소수인지 알 방도가 없다.  
하지만, 그럼에도 이 전체 명제가 옳은지는 판단할 수 있는 로직이 있다.

```
1. 0이 홀수가 아니기 때문에, 뒤에 결과로 도출되는 명제가 참이든 거짓이든 전체 명제는 참이다.

2. 결과적으로 2가 짝수가 맞다는 것을 알기 때문에 앞에 조건의 명제가 참이든 거짓이든 전체 명제는 참이다.
```

즉, 우리는 조건 명제가 **거짓**이라면 무조건 전체 명제가 참이라는 것과  
결과 명제가 **참**이라면 무조건 전체 명제가 참이 된다는 간단하고도 중요한 규칙을 알게 되었다.

이를 이용하면 다음과 같은 문제도 풀린다.

```
문제 : p와 q가 명제이고 p → q가 거짓이라고 하자. 다음 명제식의 참 거짓은 어떻게 되는가?

1) ~p → q   2) p V(or) q   3) q → p
```

잘 생각해보면 쉽게 풀 수 있다.  
먼저 문제에서 주어진 p → q 명제가 거짓이 되기 위한 조건들을 생각해보자.

- p가 거짓인 경우 : 무조건 전체 명제는 참
- q가 참인 경우 : 무조건 전체 명제는 참

즉, p는 참이고, q는 거짓인 경우 하나만 전체 명제가 거짓이 되는 경우가 된다. 그렇다면 이 사실을 가지고 보기들을 보도록 하자.

```
1) ~p → q
```

~p는 참의 반대이므로 거짓이다. 즉, "거짓 → 거짓"이 되는데, 이는 앞의 명제가 거짓이므로 무조건 참이다.  
&nbsp;

```
2) p V q
```

V가 or을 뜻하므로 p나 q가 둘 중에 참이 하나라도 있는가를 묻는 명제이다. 우리는 이미 p가 참임을 알고 있으므로 당연히 이 명제는 참이 되겠다.  
&nbsp;

```
3) q → p
```

q가 거짓이므로, 무조건 전체 명제는 참이 된다.  
&nbsp;

### **↘︎ 역, 이, 대우**

---

조금 더 나아가서 명제의 역, 이, 대우에 대해서도 수업에서 배우게 되었다.  
이는 간단하게 정리만 해놓으려고 한다.

```
명제 p → q 의 역, 이, 대우

역 : q → p
이 : ~p →  ~q
대우 : ~q → ~p
```

&nbsp;

### **↘︎ 진리표 만들기**

---

진리표란 무엇일까?  
간단하게 얘기하면, p와 q라는 명제가 들어간 큰 명제가 있을 경우에 각각의 명제가 참이나 거짓일 때에 전체 명제의 참 거짓이 어떻게 되느냐를 구하는 표라고 보면 될 것 같다.

예를 들어 다음의 명제식의 진리표를 만들어보자.

```
p ∧ (q → ~p)
```

먼저 표를 만든다.

|               |  p  |  q  | p ∧ (q → ~p) |
| :------------ | :-: | :-: | :----------: |
| 참, 거짓 여부 |  T  |  T  |      ?       |
|               |  T  |  F  |      ?       |
|               |  F  |  T  |      ?       |
|               |  F  |  F  |      ?       |

그리고 하나씩 참 거짓을 따져본다.

참고로 ∧기호는 and를 뜻하는 기호이다.  
앞에서 말했던 논리를 활용해서 풀어보면 어렵지 않다.

1. p는 참, q가 참이면 'q → ~p(거짓)'은 거짓이 되기 때문에 전체 명제식은 거짓이다.
2. p는 일단 참이고, 'q(거짓) → ~p'은 앞이 거짓이기 때문에 참이 되게 되면서 둘 다 참이 되기 때문에 전체 명제식도 참이다.
3. p가 거짓이므로 무조건 전체 명제식은 거짓이다.
4. 마찬가지로 무조건 전체 명제식은 거짓이다.

|               |  p  |  q  | p ∧ (q → ~p) |
| :------------ | :-: | :-: | :----------: |
| 참, 거짓 여부 |  T  |  T  |      F       |
|               |  T  |  F  |      T       |
|               |  F  |  T  |      F       |
|               |  F  |  F  |      F       |

주의) p → q 를 p ↔︎ q 와 혼동하면 안 된다!

### **수학적 귀납법**

---

P(n)을 증명하고자 함

1. P(1)을 따로 증명해서 참 (1이 되면 참)
2. P(n)을 참이라 가정하고 P(n+1)이 참인지 증명
3. 모든 자연수에 대해서 P(n)이 참이다.

본 강의에서는 '모든 당구공이 색이 같다' 는 명제를 증명하셨다.  
나는 조금 말만 바꾸어서 '모든 사람은 머리 색이 같다' 를 증명해보기로 하겠다.

1. 한 명의 머리 색은 당연히 같다.
2. n명의 그룹의 모든 사람들의 머리가 같다고 친다.
3. n+1 그룹에서 한 명을 빼면, n명의 그룹이 되므로 한 명을 제외한 모든 사람의 머리 색은 같다.
4. 다시 같은 n+1 그룹에서 다른 한 명을 빼도, n명의 그룹이므로 나머지 n명의 머리색이 같다.
5. 그렇게 되면 첫 번째, 두 번째에 뺐던 공 역시도 서로 같은 색이 된다.
6. 즉, n+1의 그룹에서도 모든 사람의 머리 색은 같다.

당연히 이 증명은 틀렸다. 하지만, P(n)이 틀렸다고 하면 안 된다고 하셨다.  
우리가 증명하는 것은 P(n) → P(n+1)이다.  
여기서 P(n)이 거짓이라고 해도, 거짓을 가정하는 명제는 무조건 참이기 때문에 P(n)이 거짓이라는 것은 증명이 틀렸다고 주장하는 근거로 아무런 효력이 없다.  
그렇다면 어디가 잘못된 것일까?

자, P(n+1)이 P(2)인 경우를 생각해보자. (n = 1)  
그렇게 되면 이런 식으로 될 것이다.

1. P(2)에서 한 명을 빼면 P(1)이므로 당연히 머리 색이 같다.
2. 다시 다른 한 명을 빼도 P(1)이므로 머리 색은 같다.
3. 하지만, 뺐던 두 사람끼리는 같은 지 알 수 없다.

n이 1을 초과하는 경우에는 뺀 사람과 비교할만한 n명의 사람들이 있어서 서로 같은지 증명할 수 있었지만, 위의 경우에는 누구를 빼든 1명만 남기 때문에 다른 집합의 사람들과 비교할 수가 없게 된다. 그러므로 각각의 머리가 같은지는 알 방법이 없게 되는 것이므로 증명에 문제가 생기게 된다.

그런데, 가끔은 위의 수학적 귀납법보다 더 강한 형태를 써야하는 경우가 있다고 하셨다. 그 형태는 다음과 같다.

1. P(1)이 참
2. P(1) ∧ P(2) ∧ ... ∧ P(n) 이 모두 참
3. P(n+1)이 참이다.
4. 모든 자연수 n에 대해서 참이 된다.

마지막으로 교수님은 귀납법을 사용할 때에 주의할만한 점을 얘기해주셨다.

- 증명이 가능한 명제로 바꾸기  
  : 일상적인 용어로는 증명하기가 어렵기 때문에 (당연하다 등등) 수학적이고 구체적인 문장으로 바꾸어 표현하자.

- P(n) 혹은 P(n-1) 등을 참이라 가정하고 지나갈 때에 이것이 진짜 참인지 계산할 필요 없다.  
  : 그냥 리턴하는 값만 가지고 P(n+1) 혹은 P(n)의 값이 참이 되는지 알아보는 것이 중요하다.

- 상세한 증명을 여러번 직접 해보자!
