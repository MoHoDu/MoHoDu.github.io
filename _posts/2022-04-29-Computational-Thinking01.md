---
layout: post
title: "CT - 개요"
excerpt: "Computational Thinking 공부 1"

categories:
  - CT

tags:
  - [CT, SSAFY, Study]

toc: true
toc_sticky: true

date: 2022-04-29
last_modified_at: 2022-04-29
---

### 기초 개념

---

Computational Thinking : 컴퓨터적인 사고 연산으로써 생각하는 것을 컴퓨터가 이해할 수 있는 구조로 바꾸는 것

**자료 구조**

1. 비트연산
2. 스택
3. 큐
4. 그래프
5. 트리

**비트연산**  
Bit(비트) : 0과 1 하나만 표현하는 가장 작은 단위 (2가지 수 표현)  
Byte(바이트) : 비트 8개를 하나로 묶은 단위 (2^8인 256가지 수 표현)

- 절반은 음의 정수, 절반은 0과 양의 정수 표현
- 1byte는 -128 ~ +127까지 표현 가능
- 정수 하나 = 4byte

2진법 음수 표현법

- 0에서 원하는 수의 양수를 뺀것이 해당 수의 음수 표현
- 순서
  1. 비트를 다 바꾸어주기. 0을 1로, 1을 0으로
  2. 바꾼 비트에 0000 0001을 더해준다.  
     예시) 0000 0001 = 1(10) → 1111 1111 = -1(10)

**스택**  
후입선출(LIFO) 구조  
push, pop을 통해 요소를 넣거나 빼기 가능

**인터넷 브라우저와 스택**  
페이지가 스택에 들어가는 요소라고 생각  
뒤로 가기 기능 : 2개의 스택 필요(이전 페이지, 현재 페이지)  
prev : 뒤로 가기 위한 스택  
next : 앞으로 가기 위한 스택

- 새로운 페이지 접속 : prev에 기존 페이지 push, next는 비움
- 뒤로 가기 : next에 현재 페이지 push, prev에 top페이지를 pop해서 가져옴
- 앞으로 가기 : prev에 현재 페이지 push, next의 값을 pop함  
  → 페이지 이동과정을 보고 마지막 페이지를 답으로 적는 문제가 출제될 수도 있음

**큐**  
선입선출(FIFO) 구조  
enqueue(또는 push), dequeue(또는 pop)을 통해 요소를 넣거나 빼기 가능

**원형 테이블 유형**

```
n명의 사람이 원형 테이블로 앉아있을 때, 1번 사람부터 원에서 나간 뒤에 나간사람으로부터 k번째 사람이 그 다음 차례로 이어서 나가는 문제이다.
그렇게 하여 모든 사람이 나갈 때까지 과정을 반복한 뒤에 나간 순서대로 멤버의 번호를 나열하면 된다.
이를 요세푸스 순열이라고 하며, (n, k)-요세푸스 순열이라고 쓸 수 있다.

예를 들어서 n=7, k=3인 (7, 3)-요세푸스 순열일 때,
1 - 2 - 3 - 4 - 5 - 6 - 7 의 멤버가 있으면,
1 - 2 - (3) - 4 - 5 - 6 - 7 로 3이 가장 먼저 나가고
1 - 2 - 4 - 5 - (6) - 7 로 6이 그 다음 나가고
1 - (2) - 4 - 5 - 7 로 2가 그 다음 나가고
1 - 4 - 5 - (7) 로 7이 그 다음 나가고
1 - 4 - (5) 로 5가 그 다음 나가고
(1) - 4 로 1이 그 다음 나가고
(4) 로 4가 마지막으로 나가게 될 것이기 때문에...

3, 6, 2, 7, 5, 1, 4 순서대로 나가는 것을 찾으면 된다.
```

**↘︎ 큐로 푸는 방법**  
n개의 배열에 1부터 n까지 넣고 k-1까지의 인자를 앞에서부터 dequeue 후에 다시 enqueue한다.  
이후에 k번째 인자를 dequeue하여 없애고, 모든 인자가 사라질 때까지 반복한다.

**예상 문제**

```
(9, 4)-요세푸스 순열일 때 출력값은?
```

1~9를 가진 배열을 저장한다.

- [1, 2, 3, 4, 5, 6, 7, 8, 9]

k-1인 3번까지는 첫번째 인자를 dequeue 후에 enqueue한다.

- [4, 5, 6, 7, 8, 9, 1, 2, 3]

k번째에서 첫번째 인자를 dequeue하여 없애고 결과 리스트에 append 한다.

- [5, 6, 7, 8, 9, 1, 2, 3] / result = [4]

이 과정을 모든 인자가 없어질 때까지 반복하면 답이 나온다.

- result = [4, 8, 3, 9, 6, 5, 7, 2, 1]

사실 그냥 하나씩 빼보면서 답을 구하는게 훨씬 빠르기는 하다...

**그래프**  
정보들 사이에 관계가 있는 자료구조  
방향이 있느냐로 구분! 유향 / 무향 그래프  
싸이클(Cycle) : 같은 간선을 두번 이상 지나지 않고 돌아올 수 있는 경우 → 자주 이용

**예상 문제 - 구슬 찾기**  
(백준 - https://www.acmicpc.net/problem/2617)

**↘︎ 문제 내용**

```
모양은 같으나, 무게가 모두 다른 N개의 구슬이 있다. N은 홀수이며, 구슬에는 번호가 1,2,...,N으로 붙어 있다. 이 구슬 중에서 무게가 전체의 중간인 (무게 순서로 (N+1)/2번째) 구슬을 찾기 위해서 아래와 같은 일을 하려 한다.

우리에게 주어진 것은 양팔 저울이다. 한 쌍의 구슬을 골라서 양팔 저울의 양쪽에 하나씩 올려 보면 어느 쪽이 무거운가를 알 수 있다. 이렇게 M개의 쌍을 골라서 각각 양팔 저울에 올려서 어느 것이 무거운가를 모두 알아냈다. 이 결과를 이용하여 무게가 중간이 될 가능성이 전혀 없는 구슬들은 먼저 제외한다.

예를 들어, N=5이고, M=4 쌍의 구슬에 대해서 어느 쪽이 무거운가를 알아낸 결과가 아래에 있다.

구슬 2번이 구슬 1번보다 무겁다.
구슬 4번이 구슬 3번보다 무겁다.
구슬 5번이 구슬 1번보다 무겁다.
구슬 4번이 구슬 2번보다 무겁다.
위와 같이 네 개의 결과만을 알고 있으면, 무게가 중간인 구슬을 정확하게 찾을 수는 없지만, 1번 구슬과 4번 구슬은 무게가 중간인 구슬이 절대 될 수 없다는 것은 확실히 알 수 있다. 1번 구슬보다 무거운 것이 2, 4, 5번 구슬이고, 4번 보다 가벼운 것이 1, 2, 3번이다. 따라서 답은 2개이다.

M 개의 쌍에 대한 결과를 보고 무게가 중간인 구슬이 될 수 없는 구슬의 개수를 구하는 프로그램을 작성하시오.
```

**↘︎ 입력**

```
첫 줄은 구슬의 개수를 나타내는 정수 N(1 ≤ N ≤ 99)과 저울에 올려 본 쌍의 개수 M(1 ≤ M ≤ N(N-1)/2)이 주어진다. 그 다음 M 개의 줄은 각 줄마다 두 개의 구슬 번호가 주어지는데, 앞 번호의 구슬이 뒤 번호의 구슬보다 무겁다는 것을 뜻한다.
```

**↘︎ 출력**

```
첫 줄에 무게가 중간이 절대로 될 수 없는 구슬의 수를 출력 한다.
```

**↘︎ CT 문제(예제 입력)**

```
5 4
2 1
4 3
5 1
4 2
```

그래프로 각 번호의 구슬을 연결시켜서 해결할 수 있다.  
DFS, BFS를 사용한다.

**↘︎ 출력 답안**

```
2
```

### **DFS**

: Depth-First Search

깊이 우선 탐색으로 스택이나 재귀 함수를 이용하여 처리

1. 탐색 시작 노드를 삽입 후 방문 처리
2. 스택 최상단 노드에 방문하지 않은 인접 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문 처리하고, 방문하지 않은 인접 노드가 없으면 최상단 노드를 꺼낸다.
3. 2번을 수행할 수 없을 때까지 반복한다.

**사용하는 경우**

- 깊은 단계에 있는 노드를 최우선적으로 검색할 경우
- 한 경로상의 노드를 기억하므로 BFS보다 적은 메모리 사용
- 이동 시마다 가중치가 붙어서 이동하거나 이동 과정에서 여러 제약이 존재하는 경우

**단점**

- 이를 통해 구해진 해가 최단 경로라는 보장이 없음
- 해가 아니라도 그 경로가 끝나는 때까지 탐색하므로 시간이 오래 걸릴 수 있음

### **BFS**

: Breadth-First Search

너비 우선 탐색으로 주로 최단 경로 탐색 문제에서 사용

**사용하는 경우**

- 최단 경로를 알고 싶은 경우
- 최단 경로가 존재하면 깊이가 무한정 깊어져도 답을 찾을 수 있음

**단점**

- 경로가 매우 길 경우에 탐색의 가지수가 급격하게 증가하면서 기억해야할 공간도 그만큼 필요로 하게 됨
- 해가 존재하지 않을 경우에, 유한 그래프에서는 모든 탐색을 끝낸 뒤에 실패로 처리하지만, 무한 그래프라면 해도 못 찾을 뿐더러 탐색을 끝내지도 못함

**예상 문제 - DFS와 BFS**  
(백준 - https://www.acmicpc.net/problem/1260)

**↘︎ 믄제 내용**

```
그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다. 정점 번호는 1번부터 N번까지이다.
```

**↘︎ 입력**

```
첫째 줄에 정점의 개수 N(1 ≤ N ≤ 1,000), 간선의 개수 M(1 ≤ M ≤ 10,000), 탐색을 시작할 정점의 번호 V가 주어진다. 다음 M개의 줄에는 간선이 연결하는 두 정점의 번호가 주어진다. 어떤 두 정점 사이에 여러 개의 간선이 있을 수 있다. 입력으로 주어지는 간선은 양방향이다.
```

**↘︎ 출력**

```
첫째 줄에 DFS를 수행한 결과를, 그 다음 줄에는 BFS를 수행한 결과를 출력한다. V부터 방문된 점을 순서대로 출력하면 된다.
```

**↘︎ CT 문제(예제 입력)**

```
4 5 1
1 2
1 3
1 4
2 4
3 4
```

**↘︎ 예제1 답안**

```
1 2 4 3
1 2 3 4
```

**↘︎ CT 문제2(예제 입력2)**

```
5 5 3
5 4
5 2
1 2
3 4
3 1
```

**↘︎ 예제2 답안**

```
3 1 2 5 4
3 1 4 2 5
```

**↘︎ CT 문제2(예제 입력3)**

```
1000 1 1000
999 1000
```

**↘︎ 예제3 답안**

```
1000 999
1000 999
```
